open Core
open Parsing.LexAndParse

let get_file_extension filename =
  String.split_on_chars filename ~on:['.'] |> List.last |> Option.value ~default:""

let rec remove_last_elem_list = function
  | []      -> []
  | [_]     -> []
  | x :: xs -> x :: remove_last_elem_list xs

let get_output_file filename =
  String.split_on_chars filename ~on:['.']
  |> fun split_filename ->
  remove_last_elem_list split_filename
  (* remove file ending *)
  |> fun filename_without_ending ->
  String.concat ~sep:"." (filename_without_ending @ ["ir"])

let miyu_file =
  let error_not_file filename =
    eprintf "'%s' is not a bolt file. Hint: use the .miyu extension\n%!" filename ;
    exit 1 in
  Command.Spec.Arg_type.create (fun filename ->
      match Sys.is_file filename with
      | `Yes           ->
          if get_file_extension filename = "miyu" then filename
          else error_not_file filename
      | `No | `Unknown -> error_not_file filename)

let maybe_pprint_ast should_pprint_ast pprintfun ast =
  if should_pprint_ast then (
    Fmt.pf Fmt.stdout "abc" ;
    pprintfun Fmt.stdout ast ;
    Error (Error.of_string "")
    (* This ends the program (preserving existing regression tests if subsequent pipeline
       changes) *) )
  else Ok ast

let compile_program_ir ?(should_pprint_past = true) ?compile_out_file lexbuf =
  let open Result in
  let file_str =
    match compile_out_file with Some file -> get_output_file file | None -> "" in
  parse_program lexbuf
  >>= maybe_pprint_ast should_pprint_past pprint_parsed_ast
  |> function
  | Ok program ->
      pprint_parsed_ast Fmt.stdout program
      (* ( match compile_out_file with | Some file_name -> Out_channel.with_file file_name
         ~f:(fun file_oc -> ir_gen_protobuf program file_oc) | None -> ir_gen_protobuf
         program stdout ) *)
  | Error e    ->
      print_string file_str ;
      eprintf "%s" (Error.to_string_hum e)

let command =
  Command.basic ~summary:"Run bolt programs"
    ~readme:(fun () -> "A list of execution options")
    Command.Let_syntax.(
      let%map_open should_pprint_past =
        flag "-print-parsed-ast" no_arg ~doc:" Pretty print the parsed AST of the program"
      (* and should_pprint_tast = flag "-print-typed-ast" no_arg ~doc:" Pretty print the
         typed AST of the program" and should_pprint_dast = flag "-print-desugared-ast"
         no_arg ~doc:" Pretty print the desugared AST of the program" and
         should_pprint_drast = flag "-print-data-race-ast" no_arg ~doc:" Pretty print the
         data-race checker AST of the program" and should_pprint_fir = flag
         "-print-frontend-ir" no_arg ~doc:" Pretty print the last IR generated by the
         frontend " and ignore_data_races = flag "-ignore-data-races" no_arg ~doc:" Ignore
         data races" and *)
      and filename = anon (maybe_with_default "-" ("filename" %: miyu_file)) in
      fun () ->
        In_channel.with_file filename ~f:(fun file_ic ->
            let lexbuf =
              Lexing.from_channel file_ic
              (*Create a lex buffer from the file to read in tokens *) in
            compile_program_ir lexbuf
              ~should_pprint_past
                (* ~should_pprint_tast ~should_pprint_dast ~should_pprint_drast
                   ~should_pprint_fir ~ignore_data_races *)
              ~compile_out_file:(get_output_file filename)))

let () = Command.run ~version:"1.0" ~build_info:"RWO" command
