prog: CLASS UNAME COLON CONST WHILE
##
## Ends in an error in state: 292.
##
## method_decl -> field_decorator . FN lname function_params ARROW block END [ SEMI END ]
## method_decl -> field_decorator . FN lname function_params COLON ty ARROW block END [ SEMI END ]
## method_decl -> field_decorator . FN lname gen_ty_def function_params ARROW block END [ SEMI END ]
## method_decl -> field_decorator . FN lname gen_ty_def function_params COLON ty ARROW block END [ SEMI END ]
## properties_decl -> field_decorator . lname COLON ty [ SEMI END COMMA ]
## properties_decl -> field_decorator . lname COLON ty ASSIGN arithmetic_expression [ SEMI END COMMA ]
## properties_decl -> field_decorator . lname ASSIGN arithmetic_expression [ SEMI END COMMA ]
##
## The known suffix of the stack is as follows:
## field_decorator
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME LPAREN RPAREN ARROW END WHILE
##
## Ends in an error in state: 314.
##
## class_body -> field_decl . [ END ]
## class_body -> field_decl . sep class_body [ END ]
##
## The known suffix of the stack is as follows:
## field_decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME LPAREN RPAREN ARROW TRAIT
##
## Ends in an error in state: 311.
##
## method_decl -> field_decorator FN lname function_params ARROW . block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname function_params ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME LPAREN RPAREN ARROW UNAME ELSE
##
## Ends in an error in state: 312.
##
## method_decl -> field_decorator FN lname function_params ARROW block . END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname function_params ARROW block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME LPAREN RPAREN COLON UNAME ARROW TRAIT
##
## Ends in an error in state: 308.
##
## method_decl -> field_decorator FN lname function_params COLON ty ARROW . block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname function_params COLON ty ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME LPAREN RPAREN COLON UNAME ARROW UNAME ELSE
##
## Ends in an error in state: 309.
##
## method_decl -> field_decorator FN lname function_params COLON ty ARROW block . END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname function_params COLON ty ARROW block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME LPAREN RPAREN COLON UNAME SEMI
##
## Ends in an error in state: 307.
##
## method_decl -> field_decorator FN lname function_params COLON ty . ARROW block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname function_params COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production ty_apply -> tyname 
## In state 29, spurious reduction of production plain_ty -> ty_apply 
## In state 33, spurious reduction of production mark_position(plain_ty) -> plain_ty 
## In state 35, spurious reduction of production ty -> mark_position(plain_ty) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME LPAREN RPAREN COLON WHILE
##
## Ends in an error in state: 306.
##
## method_decl -> field_decorator FN lname function_params COLON . ty ARROW block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname function_params COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME LPAREN RPAREN WHILE
##
## Ends in an error in state: 305.
##
## method_decl -> field_decorator FN lname function_params . ARROW block END [ SEMI END ]
## method_decl -> field_decorator FN lname function_params . COLON ty ARROW block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname function_params
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME SMALLER GNAME LARGER LPAREN RPAREN ARROW TRAIT
##
## Ends in an error in state: 302.
##
## method_decl -> field_decorator FN lname gen_ty_def function_params ARROW . block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname gen_ty_def function_params ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME SMALLER GNAME LARGER LPAREN RPAREN ARROW UNAME ELSE
##
## Ends in an error in state: 303.
##
## method_decl -> field_decorator FN lname gen_ty_def function_params ARROW block . END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname gen_ty_def function_params ARROW block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME SMALLER GNAME LARGER LPAREN RPAREN COLON UNAME ARROW TRAIT
##
## Ends in an error in state: 299.
##
## method_decl -> field_decorator FN lname gen_ty_def function_params COLON ty ARROW . block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname gen_ty_def function_params COLON ty ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME SMALLER GNAME LARGER LPAREN RPAREN COLON UNAME ARROW UNAME ELSE
##
## Ends in an error in state: 300.
##
## method_decl -> field_decorator FN lname gen_ty_def function_params COLON ty ARROW block . END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname gen_ty_def function_params COLON ty ARROW block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME SMALLER GNAME LARGER LPAREN RPAREN COLON UNAME SEMI
##
## Ends in an error in state: 298.
##
## method_decl -> field_decorator FN lname gen_ty_def function_params COLON ty . ARROW block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname gen_ty_def function_params COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production ty_apply -> tyname 
## In state 29, spurious reduction of production plain_ty -> ty_apply 
## In state 33, spurious reduction of production mark_position(plain_ty) -> plain_ty 
## In state 35, spurious reduction of production ty -> mark_position(plain_ty) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME SMALLER GNAME LARGER LPAREN RPAREN COLON WHILE
##
## Ends in an error in state: 297.
##
## method_decl -> field_decorator FN lname gen_ty_def function_params COLON . ty ARROW block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname gen_ty_def function_params COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME SMALLER GNAME LARGER LPAREN RPAREN WHILE
##
## Ends in an error in state: 296.
##
## method_decl -> field_decorator FN lname gen_ty_def function_params . ARROW block END [ SEMI END ]
## method_decl -> field_decorator FN lname gen_ty_def function_params . COLON ty ARROW block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname gen_ty_def function_params
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME SMALLER GNAME LARGER WHILE
##
## Ends in an error in state: 295.
##
## method_decl -> field_decorator FN lname gen_ty_def . function_params ARROW block END [ SEMI END ]
## method_decl -> field_decorator FN lname gen_ty_def . function_params COLON ty ARROW block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname gen_ty_def
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN LNAME WHILE
##
## Ends in an error in state: 294.
##
## method_decl -> field_decorator FN lname . function_params ARROW block END [ SEMI END ]
## method_decl -> field_decorator FN lname . function_params COLON ty ARROW block END [ SEMI END ]
## method_decl -> field_decorator FN lname . gen_ty_def function_params ARROW block END [ SEMI END ]
## method_decl -> field_decorator FN lname . gen_ty_def function_params COLON ty ARROW block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN lname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON FN WHILE
##
## Ends in an error in state: 293.
##
## method_decl -> field_decorator FN . lname function_params ARROW block END [ SEMI END ]
## method_decl -> field_decorator FN . lname function_params COLON ty ARROW block END [ SEMI END ]
## method_decl -> field_decorator FN . lname gen_ty_def function_params ARROW block END [ SEMI END ]
## method_decl -> field_decorator FN . lname gen_ty_def function_params COLON ty ARROW block END [ SEMI END ]
##
## The known suffix of the stack is as follows:
## field_decorator FN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON LNAME ASSIGN BOOL COMMA STATIC FN
##
## Ends in an error in state: 69.
##
## properties_decl -> field_decorator . lname COLON ty [ SEMI END COMMA ]
## properties_decl -> field_decorator . lname COLON ty ASSIGN arithmetic_expression [ SEMI END COMMA ]
## properties_decl -> field_decorator . lname ASSIGN arithmetic_expression [ SEMI END COMMA ]
##
## The known suffix of the stack is as follows:
## field_decorator
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production option(PUB) -> 
## In state 66, spurious reduction of production option(CONST) -> 
## In state 68, spurious reduction of production field_decorator -> option(STATIC) option(PUB) option(CONST) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON LNAME ASSIGN BOOL COMMA WHILE
##
## Ends in an error in state: 62.
##
## separated_nonempty_list(COMMA,properties_decl) -> properties_decl COMMA . separated_nonempty_list(COMMA,properties_decl) [ SEMI END ]
##
## The known suffix of the stack is as follows:
## properties_decl COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON LNAME ASSIGN BOOL RPAREN
##
## Ends in an error in state: 61.
##
## separated_nonempty_list(COMMA,properties_decl) -> properties_decl . [ SEMI END ]
## separated_nonempty_list(COMMA,properties_decl) -> properties_decl . COMMA separated_nonempty_list(COMMA,properties_decl) [ SEMI END ]
##
## The known suffix of the stack is as follows:
## properties_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 288, spurious reduction of production properties_decl -> field_decorator lname ASSIGN arithmetic_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON LNAME ASSIGN BOOL SEMI WHILE
##
## Ends in an error in state: 315.
##
## class_body -> field_decl sep . class_body [ END ]
##
## The known suffix of the stack is as follows:
## field_decl sep
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production nonempty_list(single_sep) -> single_sep 
## In state 11, spurious reduction of production sep -> nonempty_list(single_sep) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON LNAME ASSIGN WHILE
##
## Ends in an error in state: 287.
##
## properties_decl -> field_decorator lname ASSIGN . arithmetic_expression [ SEMI END COMMA ]
##
## The known suffix of the stack is as follows:
## field_decorator lname ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON LNAME COLON UNAME ASSIGN WHILE
##
## Ends in an error in state: 73.
##
## properties_decl -> field_decorator lname COLON ty ASSIGN . arithmetic_expression [ SEMI END COMMA ]
##
## The known suffix of the stack is as follows:
## field_decorator lname COLON ty ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON LNAME COLON UNAME RPAREN
##
## Ends in an error in state: 72.
##
## properties_decl -> field_decorator lname COLON ty . [ SEMI END COMMA ]
## properties_decl -> field_decorator lname COLON ty . ASSIGN arithmetic_expression [ SEMI END COMMA ]
##
## The known suffix of the stack is as follows:
## field_decorator lname COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production ty_apply -> tyname 
## In state 29, spurious reduction of production plain_ty -> ty_apply 
## In state 33, spurious reduction of production mark_position(plain_ty) -> plain_ty 
## In state 35, spurious reduction of production ty -> mark_position(plain_ty) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON LNAME COLON WHILE
##
## Ends in an error in state: 71.
##
## properties_decl -> field_decorator lname COLON . ty [ SEMI END COMMA ]
## properties_decl -> field_decorator lname COLON . ty ASSIGN arithmetic_expression [ SEMI END COMMA ]
##
## The known suffix of the stack is as follows:
## field_decorator lname COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON LNAME WHILE
##
## Ends in an error in state: 70.
##
## properties_decl -> field_decorator lname . COLON ty [ SEMI END COMMA ]
## properties_decl -> field_decorator lname . COLON ty ASSIGN arithmetic_expression [ SEMI END COMMA ]
## properties_decl -> field_decorator lname . ASSIGN arithmetic_expression [ SEMI END COMMA ]
##
## The known suffix of the stack is as follows:
## field_decorator lname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON PUB COMMA
##
## Ends in an error in state: 66.
##
## field_decorator -> option(STATIC) option(PUB) . option(CONST) [ LNAME FN ]
##
## The known suffix of the stack is as follows:
## option(STATIC) option(PUB)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON STATIC COMMA
##
## Ends in an error in state: 64.
##
## field_decorator -> option(STATIC) . option(PUB) option(CONST) [ LNAME FN ]
##
## The known suffix of the stack is as follows:
## option(STATIC)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME COLON WHILE
##
## Ends in an error in state: 376.
##
## plain_class_def -> CLASS class_head COLON . class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## CLASS class_head COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME LPAREN UNAME RPAREN WHILE
##
## Ends in an error in state: 375.
##
## plain_class_def -> CLASS class_head . COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## CLASS class_head
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME LPAREN UNAME SMALLER GNAME LARGER WHILE
##
## Ends in an error in state: 369.
##
## class_father -> LPAREN uname gen_ty_consume . RPAREN [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN uname gen_ty_consume
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME LPAREN UNAME WHILE
##
## Ends in an error in state: 367.
##
## class_father -> LPAREN uname . RPAREN [ COLON ]
## class_father -> LPAREN uname . gen_ty_consume RPAREN [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN uname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME LPAREN WHILE
##
## Ends in an error in state: 366.
##
## class_father -> LPAREN . uname RPAREN [ COLON ]
## class_father -> LPAREN . uname gen_ty_consume RPAREN [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME SMALLER GNAME LARGER WHILE
##
## Ends in an error in state: 372.
##
## class_head -> uname gen_ty_def . option(class_father) [ COLON ]
##
## The known suffix of the stack is as follows:
## uname gen_ty_def
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS UNAME WHILE
##
## Ends in an error in state: 365.
##
## class_head -> uname . option(class_father) [ COLON ]
## class_head -> uname . gen_ty_def option(class_father) [ COLON ]
##
## The known suffix of the stack is as follows:
## uname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: CLASS WHILE
##
## Ends in an error in state: 364.
##
## plain_class_def -> CLASS . class_head COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## CLASS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN CONST WHILE
##
## Ends in an error in state: 199.
##
## param_def -> var_decorator . lname COLON ty [ RPAREN COMMA ]
## param_def -> var_decorator . lname [ RPAREN COMMA ]
## param_def -> var_decorator . lname COLON ty ASSIGN bin_expression [ RPAREN COMMA ]
## param_def -> var_decorator . lname ASSIGN bin_expression [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN LNAME ASSIGN UNAME SEMI
##
## Ends in an error in state: 206.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## param_def -> var_decorator lname ASSIGN bin_expression . [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname ASSIGN bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN LNAME ASSIGN WHILE
##
## Ends in an error in state: 205.
##
## param_def -> var_decorator lname ASSIGN . bin_expression [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN LNAME COLON UNAME ASSIGN UNAME SEMI
##
## Ends in an error in state: 204.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## param_def -> var_decorator lname COLON ty ASSIGN bin_expression . [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname COLON ty ASSIGN bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN LNAME COLON UNAME ASSIGN WHILE
##
## Ends in an error in state: 203.
##
## param_def -> var_decorator lname COLON ty ASSIGN . bin_expression [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname COLON ty ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN LNAME COLON UNAME SEMI
##
## Ends in an error in state: 202.
##
## param_def -> var_decorator lname COLON ty . [ RPAREN COMMA ]
## param_def -> var_decorator lname COLON ty . ASSIGN bin_expression [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production ty_apply -> tyname 
## In state 29, spurious reduction of production plain_ty -> ty_apply 
## In state 33, spurious reduction of production mark_position(plain_ty) -> plain_ty 
## In state 35, spurious reduction of production ty -> mark_position(plain_ty) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN LNAME COLON WHILE
##
## Ends in an error in state: 201.
##
## param_def -> var_decorator lname COLON . ty [ RPAREN COMMA ]
## param_def -> var_decorator lname COLON . ty ASSIGN bin_expression [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN LNAME COMMA WHILE
##
## Ends in an error in state: 208.
##
## function_param_list -> param_def COMMA . function_param_list [ RPAREN ]
##
## The known suffix of the stack is as follows:
## param_def COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN LNAME WHILE
##
## Ends in an error in state: 200.
##
## param_def -> var_decorator lname . COLON ty [ RPAREN COMMA ]
## param_def -> var_decorator lname . [ RPAREN COMMA ]
## param_def -> var_decorator lname . COLON ty ASSIGN bin_expression [ RPAREN COMMA ]
## param_def -> var_decorator lname . ASSIGN bin_expression [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN RPAREN ARROW TRAIT
##
## Ends in an error in state: 247.
##
## plain_function_def -> FN lname function_params ARROW . block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname function_params ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN RPAREN ARROW UNAME ELSE
##
## Ends in an error in state: 248.
##
## plain_function_def -> FN lname function_params ARROW block . END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname function_params ARROW block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN RPAREN ARROW UNAME RPAREN
##
## Ends in an error in state: 230.
##
## block -> expression . [ END ELSE ELIF ]
## block -> expression . sep block [ END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN RPAREN ARROW UNAME SEMI TRAIT
##
## Ends in an error in state: 231.
##
## block -> expression sep . block [ END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## expression sep
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production nonempty_list(single_sep) -> single_sep 
## In state 11, spurious reduction of production sep -> nonempty_list(single_sep) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN RPAREN COLON UNAME ARROW TRAIT
##
## Ends in an error in state: 244.
##
## plain_function_def -> FN lname function_params COLON ty ARROW . block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname function_params COLON ty ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN RPAREN COLON UNAME ARROW UNAME ELSE
##
## Ends in an error in state: 245.
##
## plain_function_def -> FN lname function_params COLON ty ARROW block . END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname function_params COLON ty ARROW block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN RPAREN COLON UNAME SEMI
##
## Ends in an error in state: 243.
##
## plain_function_def -> FN lname function_params COLON ty . ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname function_params COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production ty_apply -> tyname 
## In state 29, spurious reduction of production plain_ty -> ty_apply 
## In state 33, spurious reduction of production mark_position(plain_ty) -> plain_ty 
## In state 35, spurious reduction of production ty -> mark_position(plain_ty) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN RPAREN COLON WHILE
##
## Ends in an error in state: 242.
##
## plain_function_def -> FN lname function_params COLON . ty ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname function_params COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN RPAREN WHILE
##
## Ends in an error in state: 241.
##
## plain_function_def -> FN lname function_params . ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
## plain_function_def -> FN lname function_params . COLON ty ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname function_params
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME LPAREN WHILE
##
## Ends in an error in state: 197.
##
## function_params -> LPAREN . RPAREN [ COLON ARROW ]
## function_params -> LPAREN . function_param_list RPAREN [ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME SMALLER GNAME LARGER LPAREN RPAREN ARROW TRAIT
##
## Ends in an error in state: 238.
##
## plain_function_def -> FN lname gen_ty_def function_params ARROW . block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname gen_ty_def function_params ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME SMALLER GNAME LARGER LPAREN RPAREN ARROW UNAME ELSE
##
## Ends in an error in state: 239.
##
## plain_function_def -> FN lname gen_ty_def function_params ARROW block . END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname gen_ty_def function_params ARROW block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME SMALLER GNAME LARGER LPAREN RPAREN COLON UNAME ARROW TRAIT
##
## Ends in an error in state: 216.
##
## plain_function_def -> FN lname gen_ty_def function_params COLON ty ARROW . block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname gen_ty_def function_params COLON ty ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME SMALLER GNAME LARGER LPAREN RPAREN COLON UNAME ARROW UNAME ELSE
##
## Ends in an error in state: 236.
##
## plain_function_def -> FN lname gen_ty_def function_params COLON ty ARROW block . END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname gen_ty_def function_params COLON ty ARROW block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME SMALLER GNAME LARGER LPAREN RPAREN COLON UNAME SEMI
##
## Ends in an error in state: 215.
##
## plain_function_def -> FN lname gen_ty_def function_params COLON ty . ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname gen_ty_def function_params COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production ty_apply -> tyname 
## In state 29, spurious reduction of production plain_ty -> ty_apply 
## In state 33, spurious reduction of production mark_position(plain_ty) -> plain_ty 
## In state 35, spurious reduction of production ty -> mark_position(plain_ty) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME SMALLER GNAME LARGER LPAREN RPAREN COLON WHILE
##
## Ends in an error in state: 214.
##
## plain_function_def -> FN lname gen_ty_def function_params COLON . ty ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname gen_ty_def function_params COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME SMALLER GNAME LARGER LPAREN RPAREN WHILE
##
## Ends in an error in state: 213.
##
## plain_function_def -> FN lname gen_ty_def function_params . ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
## plain_function_def -> FN lname gen_ty_def function_params . COLON ty ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname gen_ty_def function_params
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME SMALLER GNAME LARGER WHILE
##
## Ends in an error in state: 212.
##
## plain_function_def -> FN lname gen_ty_def . function_params ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
## plain_function_def -> FN lname gen_ty_def . function_params COLON ty ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname gen_ty_def
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN LNAME WHILE
##
## Ends in an error in state: 196.
##
## plain_function_def -> FN lname . function_params ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
## plain_function_def -> FN lname . function_params COLON ty ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
## plain_function_def -> FN lname . gen_ty_def function_params ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
## plain_function_def -> FN lname . gen_ty_def function_params COLON ty ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN lname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FN WHILE
##
## Ends in an error in state: 195.
##
## plain_function_def -> FN . lname function_params ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
## plain_function_def -> FN . lname function_params COLON ty ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
## plain_function_def -> FN . lname gen_ty_def function_params ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
## plain_function_def -> FN . lname gen_ty_def function_params COLON ty ARROW block END [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME FOR UNAME COLON WHILE
##
## Ends in an error in state: 347.
##
## plain_impl_def -> IMPL uname FOR uname COLON . class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname FOR uname COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME FOR UNAME SMALLER GNAME LARGER COLON WHILE
##
## Ends in an error in state: 351.
##
## plain_impl_def -> IMPL uname FOR uname gen_ty_consume COLON . class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname FOR uname gen_ty_consume COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME FOR UNAME SMALLER GNAME LARGER WHILE
##
## Ends in an error in state: 350.
##
## plain_impl_def -> IMPL uname FOR uname gen_ty_consume . COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname FOR uname gen_ty_consume
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME FOR UNAME WHILE
##
## Ends in an error in state: 346.
##
## plain_impl_def -> IMPL uname FOR uname . COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL uname FOR uname . gen_ty_consume COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname FOR uname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME FOR WHILE
##
## Ends in an error in state: 345.
##
## plain_impl_def -> IMPL uname FOR . uname COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL uname FOR . uname gen_ty_consume COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME SMALLER GNAME LARGER FOR UNAME COLON WHILE
##
## Ends in an error in state: 357.
##
## plain_impl_def -> IMPL uname gen_ty_def FOR uname COLON . class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname gen_ty_def FOR uname COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME SMALLER GNAME LARGER FOR UNAME SMALLER GNAME LARGER COLON WHILE
##
## Ends in an error in state: 361.
##
## plain_impl_def -> IMPL uname gen_ty_def FOR uname gen_ty_consume COLON . class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname gen_ty_def FOR uname gen_ty_consume COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME SMALLER GNAME LARGER FOR UNAME SMALLER GNAME LARGER WHILE
##
## Ends in an error in state: 360.
##
## plain_impl_def -> IMPL uname gen_ty_def FOR uname gen_ty_consume . COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname gen_ty_def FOR uname gen_ty_consume
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME SMALLER GNAME LARGER FOR UNAME WHILE
##
## Ends in an error in state: 356.
##
## plain_impl_def -> IMPL uname gen_ty_def FOR uname . COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL uname gen_ty_def FOR uname . gen_ty_consume COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname gen_ty_def FOR uname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME SMALLER GNAME LARGER FOR WHILE
##
## Ends in an error in state: 355.
##
## plain_impl_def -> IMPL uname gen_ty_def FOR . uname COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL uname gen_ty_def FOR . uname gen_ty_consume COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname gen_ty_def FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME SMALLER GNAME LARGER WHILE
##
## Ends in an error in state: 354.
##
## plain_impl_def -> IMPL uname gen_ty_def . FOR uname COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL uname gen_ty_def . FOR uname gen_ty_consume COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname gen_ty_def
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL UNAME WHILE
##
## Ends in an error in state: 344.
##
## plain_impl_def -> IMPL uname . FOR uname COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL uname . gen_ty_def FOR uname COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL uname . FOR uname gen_ty_consume COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL uname . gen_ty_def FOR uname gen_ty_consume COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL uname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPL WHILE
##
## Ends in an error in state: 343.
##
## plain_impl_def -> IMPL . uname FOR uname COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL . uname gen_ty_def FOR uname COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL . uname FOR uname gen_ty_consume COLON class_body END [ SEMI EOF ]
## plain_impl_def -> IMPL . uname gen_ty_def FOR uname gen_ty_consume COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME COMMA WHILE
##
## Ends in an error in state: 341.
##
## separated_nonempty_list(COMMA,module_path_list) -> module_path_list COMMA . separated_nonempty_list(COMMA,module_path_list) [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## module_path_list COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME DOT LPAREN LNAME RPAREN WHILE
##
## Ends in an error in state: 340.
##
## separated_nonempty_list(COMMA,module_path_list) -> module_path_list . [ SEMI EOF ]
## separated_nonempty_list(COMMA,module_path_list) -> module_path_list . COMMA separated_nonempty_list(COMMA,module_path_list) [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## module_path_list
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME DOT LPAREN UNAME COMMA WHILE
##
## Ends in an error in state: 338.
##
## separated_nonempty_list(COMMA,module_path) -> module_path COMMA . separated_nonempty_list(COMMA,module_path) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## module_path COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME DOT LPAREN UNAME DOT WHILE
##
## Ends in an error in state: 335.
##
## module_path -> name DOT . module_path [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## name DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME DOT LPAREN UNAME WHILE
##
## Ends in an error in state: 334.
##
## module_path -> name . [ RPAREN COMMA ]
## module_path -> name . DOT module_path [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME DOT LPAREN WHILE
##
## Ends in an error in state: 331.
##
## module_path_list -> module_root_path LPAREN . separated_nonempty_list(COMMA,module_path) RPAREN [ SEMI EOF COMMA ]
##
## The known suffix of the stack is as follows:
## module_root_path LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME DOT WHILE
##
## Ends in an error in state: 328.
##
## module_root_path -> name DOT . [ LPAREN ]
## module_root_path -> name DOT . module_root_path [ LPAREN ]
## separated_nonempty_list(DOT,name) -> name DOT . separated_nonempty_list(DOT,name) [ SEMI EOF COMMA ]
##
## The known suffix of the stack is as follows:
## name DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME SEMI STAR
##
## Ends in an error in state: 8.
##
## nonempty_list(single_sep) -> single_sep . [ WHILE UNAME TRAIT THIS STRING STATIC RET PUB PRINT NULL NOT NEW MINUS LPAREN LOOP LNAME LET LBRACK INT IMPORT IMPL IF FOR FN FLOAT EOF END ELSE ELIF DEL CONTINUE CONST CLASS BREAK BOOL BEGIN ]
## nonempty_list(single_sep) -> single_sep . nonempty_list(single_sep) [ WHILE UNAME TRAIT THIS STRING STATIC RET PUB PRINT NULL NOT NEW MINUS LPAREN LOOP LNAME LET LBRACK INT IMPORT IMPL IF FOR FN FLOAT EOF END ELSE ELIF DEL CONTINUE CONST CLASS BREAK BOOL BEGIN ]
##
## The known suffix of the stack is as follows:
## single_sep
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME SEMI WHILE
##
## Ends in an error in state: 388.
##
## pkg_body -> pkg_field_decl sep . pkg_body [ EOF ]
##
## The known suffix of the stack is as follows:
## pkg_field_decl sep
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production nonempty_list(single_sep) -> single_sep 
## In state 11, spurious reduction of production sep -> nonempty_list(single_sep) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT UNAME WHILE
##
## Ends in an error in state: 327.
##
## module_root_path -> name . DOT [ LPAREN ]
## module_root_path -> name . DOT module_root_path [ LPAREN ]
## separated_nonempty_list(DOT,name) -> name . [ SEMI EOF COMMA ]
## separated_nonempty_list(DOT,name) -> name . DOT separated_nonempty_list(DOT,name) [ SEMI EOF COMMA ]
##
## The known suffix of the stack is as follows:
## name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IMPORT WHILE
##
## Ends in an error in state: 324.
##
## plain_import_decl -> IMPORT . separated_nonempty_list(COMMA,module_path_list) [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## IMPORT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET CONST WHILE
##
## Ends in an error in state: 172.
##
## plain_var_decl -> var_decorator . lname COLON ty [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
## plain_var_decl -> var_decorator . lname COLON ty ASSIGN arithmetic_expression [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
## plain_var_decl -> var_decorator . lname ASSIGN arithmetic_expression [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN BOOL COMMA WHILE
##
## Ends in an error in state: 181.
##
## separated_nonempty_list(COMMA,var_decl) -> var_decl COMMA . separated_nonempty_list(COMMA,var_decl) [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## var_decl COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN BOOL RBRACK
##
## Ends in an error in state: 180.
##
## separated_nonempty_list(COMMA,var_decl) -> var_decl . [ SEMI RPAREN EOF END ELSE ELIF ]
## separated_nonempty_list(COMMA,var_decl) -> var_decl . COMMA separated_nonempty_list(COMMA,var_decl) [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## var_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 179, spurious reduction of production plain_var_decl -> var_decorator lname ASSIGN arithmetic_expression 
## In state 183, spurious reduction of production mark_position(plain_var_decl) -> plain_var_decl 
## In state 185, spurious reduction of production var_decl -> mark_position(plain_var_decl) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LBRACK UNAME COMMA WHILE
##
## Ends in an error in state: 160.
##
## separated_nonempty_list(COMMA,arithmetic_expression) -> arithmetic_expression COMMA . separated_nonempty_list(COMMA,arithmetic_expression) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## arithmetic_expression COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LBRACK UNAME SEMI
##
## Ends in an error in state: 159.
##
## separated_nonempty_list(COMMA,arithmetic_expression) -> arithmetic_expression . [ RBRACK ]
## separated_nonempty_list(COMMA,arithmetic_expression) -> arithmetic_expression . COMMA separated_nonempty_list(COMMA,arithmetic_expression) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## arithmetic_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LBRACK WHILE
##
## Ends in an error in state: 85.
##
## primary_expression_start -> LBRACK . RBRACK [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_start -> LBRACK . separated_nonempty_list(COMMA,arithmetic_expression) RBRACK [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LNAME LPAREN LNAME ASSIGN UNAME SEMI
##
## Ends in an error in state: 280.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## param_call -> lname ASSIGN bin_expression . [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## lname ASSIGN bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LNAME LPAREN LNAME ASSIGN WHILE
##
## Ends in an error in state: 279.
##
## param_call -> lname ASSIGN . bin_expression [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## lname ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LNAME LPAREN LNAME WHILE
##
## Ends in an error in state: 278.
##
## name -> lname . [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LBRACK LARGER EQUAL DOT DIVIDE COMMA COLONCOLON BARBAR AMPERAMPER ]
## param_call -> lname . ASSIGN bin_expression [ RPAREN COMMA ]
## primary_expression_access -> lname . function_call_params [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LBRACK LARGER EQUAL DOT DIVIDE COMMA BARBAR AMPERAMPER ]
## primary_expression_access -> lname . function_call_params COLONCOLON gen_ty_consume [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LBRACK LARGER EQUAL DOT DIVIDE COMMA BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## lname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LNAME LPAREN RPAREN COLONCOLON WHILE
##
## Ends in an error in state: 105.
##
## primary_expression_access -> lname function_call_params COLONCOLON . gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## lname function_call_params COLONCOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LNAME LPAREN RPAREN WHILE
##
## Ends in an error in state: 104.
##
## primary_expression_access -> lname function_call_params . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> lname function_call_params . COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## lname function_call_params
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LNAME LPAREN UNAME COMMA WHILE
##
## Ends in an error in state: 276.
##
## param_call_list -> param_call COMMA . param_call_list [ RPAREN ]
##
## The known suffix of the stack is as follows:
## param_call COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LNAME LPAREN UNAME SEMI
##
## Ends in an error in state: 281.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ RPAREN PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COMMA BARBAR AMPERAMPER ]
## param_call -> bin_expression . [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LNAME LPAREN WHILE
##
## Ends in an error in state: 80.
##
## function_call_params -> LPAREN . RPAREN [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLONCOLON COLON BARBAR ASSIGN AMPERAMPER ]
## function_call_params -> LPAREN . param_call_list RPAREN [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLONCOLON COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LNAME WHILE
##
## Ends in an error in state: 103.
##
## name -> lname . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLONCOLON COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> lname . function_call_params [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> lname . function_call_params COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## lname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN BEGIN TRAIT
##
## Ends in an error in state: 224.
##
## plain_expression -> BEGIN . block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## BEGIN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN BEGIN UNAME ELSE
##
## Ends in an error in state: 234.
##
## plain_expression -> BEGIN block . END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## BEGIN block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN BREAK LPAREN WHILE
##
## Ends in an error in state: 222.
##
## plain_expression -> BREAK LPAREN . arithmetic_expression [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## BREAK LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN BREAK WHILE
##
## Ends in an error in state: 221.
##
## plain_expression -> BREAK . LPAREN arithmetic_expression [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## BREAK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN CONTINUE WHILE
##
## Ends in an error in state: 219.
##
## plain_expression -> CONTINUE . arithmetic_expression [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## CONTINUE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN DEL WHILE
##
## Ends in an error in state: 217.
##
## plain_expression -> DEL . lname [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## DEL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN FOR LNAME IN UNAME COLON TRAIT
##
## Ends in an error in state: 194.
##
## plain_expression -> FOR lname IN unary_expression COLON . block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FOR lname IN unary_expression COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN FOR LNAME IN UNAME COLON UNAME ELSE
##
## Ends in an error in state: 250.
##
## plain_expression -> FOR lname IN unary_expression COLON block . END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FOR lname IN unary_expression COLON block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN FOR LNAME IN UNAME STAR
##
## Ends in an error in state: 193.
##
## plain_expression -> FOR lname IN unary_expression . COLON block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FOR lname IN unary_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN FOR LNAME IN WHILE
##
## Ends in an error in state: 192.
##
## plain_expression -> FOR lname IN . unary_expression COLON block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FOR lname IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN FOR LNAME WHILE
##
## Ends in an error in state: 191.
##
## plain_expression -> FOR lname . IN unary_expression COLON block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FOR lname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN FOR WHILE
##
## Ends in an error in state: 190.
##
## plain_expression -> FOR . lname IN unary_expression COLON block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN IF UNAME COLON ELIF UNAME COLON TRAIT
##
## Ends in an error in state: 255.
##
## elif_expression -> ELIF bin_expression COLON . block [ END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## ELIF bin_expression COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN IF UNAME COLON ELIF UNAME SEMI
##
## Ends in an error in state: 254.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## elif_expression -> ELIF bin_expression . COLON block [ END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## ELIF bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN IF UNAME COLON ELIF WHILE
##
## Ends in an error in state: 253.
##
## elif_expression -> ELIF . bin_expression COLON block [ END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## ELIF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN IF UNAME COLON ELSE COLON BOOL ELSE
##
## Ends in an error in state: 261.
##
## if_expression -> IF bin_expression COLON block list(elif_expression) option(else_expression) . END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## IF bin_expression COLON block list(elif_expression) option(else_expression)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
## In state 260, spurious reduction of production else_expression -> ELSE COLON block 
## In state 263, spurious reduction of production option(else_expression) -> else_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN IF UNAME COLON ELSE COLON TRAIT
##
## Ends in an error in state: 259.
##
## else_expression -> ELSE COLON . block [ END ]
##
## The known suffix of the stack is as follows:
## ELSE COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN IF UNAME COLON ELSE WHILE
##
## Ends in an error in state: 258.
##
## else_expression -> ELSE . COLON block [ END ]
##
## The known suffix of the stack is as follows:
## ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN IF UNAME COLON TRAIT
##
## Ends in an error in state: 189.
##
## if_expression -> IF bin_expression COLON . block list(elif_expression) option(else_expression) END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## IF bin_expression COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN IF UNAME SEMI
##
## Ends in an error in state: 188.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ PLUS NEQ MOD MINUS LEQ LARGER EQUAL DIVIDE COLON BARBAR AMPERAMPER ]
## if_expression -> IF bin_expression . COLON block list(elif_expression) option(else_expression) END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## IF bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN IF WHILE
##
## Ends in an error in state: 187.
##
## if_expression -> IF . bin_expression COLON block list(elif_expression) option(else_expression) END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN LOOP TRAIT
##
## Ends in an error in state: 170.
##
## plain_expression -> LOOP . block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## LOOP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN LOOP UNAME ELSE
##
## Ends in an error in state: 266.
##
## plain_expression -> LOOP block . END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## LOOP block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN PRINT LPAREN UNAME SEMI
##
## Ends in an error in state: 168.
##
## plain_expression -> PRINT LPAREN arithmetic_expression . RPAREN [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## PRINT LPAREN arithmetic_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN PRINT LPAREN WHILE
##
## Ends in an error in state: 167.
##
## plain_expression -> PRINT LPAREN . arithmetic_expression RPAREN [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## PRINT LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN PRINT WHILE
##
## Ends in an error in state: 166.
##
## plain_expression -> PRINT . LPAREN arithmetic_expression RPAREN [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## PRINT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN RET WHILE
##
## Ends in an error in state: 164.
##
## plain_expression -> RET . arithmetic_expression [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## RET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN TRAIT
##
## Ends in an error in state: 83.
##
## primary_expression_start -> LPAREN . plain_expression RPAREN [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN UNAME SEMI
##
## Ends in an error in state: 270.
##
## primary_expression_start -> LPAREN plain_expression . RPAREN [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## LPAREN plain_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN WHILE UNAME COLON TRAIT
##
## Ends in an error in state: 163.
##
## plain_expression -> WHILE arithmetic_expression COLON . block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## WHILE arithmetic_expression COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN WHILE UNAME COLON UNAME ELSE
##
## Ends in an error in state: 268.
##
## plain_expression -> WHILE arithmetic_expression COLON block . END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## WHILE arithmetic_expression COLON block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
## In state 233, spurious reduction of production plain_expression -> arithmetic_expression 
## In state 227, spurious reduction of production mark_position(plain_expression) -> plain_expression 
## In state 228, spurious reduction of production expression -> mark_position(plain_expression) 
## In state 230, spurious reduction of production block -> expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN WHILE UNAME SEMI
##
## Ends in an error in state: 162.
##
## plain_expression -> WHILE arithmetic_expression . COLON block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## WHILE arithmetic_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN LPAREN WHILE WHILE
##
## Ends in an error in state: 84.
##
## plain_expression -> WHILE . arithmetic_expression COLON block END [ SEMI RPAREN END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## WHILE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN MINUS WHILE
##
## Ends in an error in state: 82.
##
## unary_expression -> MINUS . unary_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN NEW UNAME LPAREN RPAREN COLONCOLON WHILE
##
## Ends in an error in state: 283.
##
## primary_expression_start -> NEW uname function_call_params COLONCOLON . gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## NEW uname function_call_params COLONCOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN NEW UNAME LPAREN RPAREN WHILE
##
## Ends in an error in state: 282.
##
## primary_expression_start -> NEW uname function_call_params . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_start -> NEW uname function_call_params . COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## NEW uname function_call_params
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN NEW UNAME WHILE
##
## Ends in an error in state: 79.
##
## primary_expression_start -> NEW uname . function_call_params [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_start -> NEW uname . function_call_params COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## NEW uname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN NEW WHILE
##
## Ends in an error in state: 78.
##
## primary_expression_start -> NEW . uname function_call_params [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_start -> NEW . uname function_call_params COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## NEW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN NOT WHILE
##
## Ends in an error in state: 77.
##
## unary_expression -> NOT . unary_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## NOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN THIS WHILE
##
## Ends in an error in state: 94.
##
## plain_primary_expression -> primary_expression . LBRACK arithmetic_expression RBRACK [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression . DOT lname [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression . DOT lname function_call_params [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression . DOT lname COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression . DOT lname function_call_params COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## unary_expression -> primary_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## primary_expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME AMPERAMPER UNAME PLUS_ASSIGN
##
## Ends in an error in state: 135.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression AMPERAMPER bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression AMPERAMPER bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME AMPERAMPER WHILE
##
## Ends in an error in state: 134.
##
## bin_expression -> bin_expression AMPERAMPER . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression AMPERAMPER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME ASSIGN WHILE
##
## Ends in an error in state: 155.
##
## plain_assignment -> unary_expression ASSIGN . arithmetic_expression [ SEMI RPAREN RBRACK EOF END ELSE ELIF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## unary_expression ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME BARBAR UNAME PLUS_ASSIGN
##
## Ends in an error in state: 133.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression BARBAR bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression BARBAR bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME BARBAR WHILE
##
## Ends in an error in state: 132.
##
## bin_expression -> bin_expression BARBAR . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression BARBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME COLONCOLON WHILE
##
## Ends in an error in state: 99.
##
## primary_expression_start -> name COLONCOLON . gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## name COLONCOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME DIVIDE BOOL PLUS_ASSIGN
##
## Ends in an error in state: 108.
##
## arithmetic_expression -> bin_expression . [ SEMI RPAREN RBRACK EOF END ELSE ELIF COMMA COLON ]
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
## In state 119, spurious reduction of production bin_expression -> bin_expression DIVIDE bin_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME DIVIDE WHILE
##
## Ends in an error in state: 118.
##
## bin_expression -> bin_expression DIVIDE . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression DIVIDE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME DIV_ASSIGN WHILE
##
## Ends in an error in state: 153.
##
## plain_assignment -> unary_expression DIV_ASSIGN . arithmetic_expression [ SEMI RPAREN RBRACK EOF END ELSE ELIF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## unary_expression DIV_ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME DOT LNAME COLONCOLON WHILE
##
## Ends in an error in state: 141.
##
## primary_expression_access -> primary_expression DOT lname COLONCOLON . gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## primary_expression DOT lname COLONCOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME DOT LNAME LPAREN RPAREN COLONCOLON WHILE
##
## Ends in an error in state: 144.
##
## primary_expression_access -> primary_expression DOT lname function_call_params COLONCOLON . gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## primary_expression DOT lname function_call_params COLONCOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME DOT LNAME LPAREN RPAREN WHILE
##
## Ends in an error in state: 143.
##
## primary_expression_access -> primary_expression DOT lname function_call_params . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression DOT lname function_call_params . COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## primary_expression DOT lname function_call_params
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME DOT LNAME WHILE
##
## Ends in an error in state: 140.
##
## primary_expression_access -> primary_expression DOT lname . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression DOT lname . function_call_params [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression DOT lname . COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression DOT lname . function_call_params COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## primary_expression DOT lname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME DOT WHILE
##
## Ends in an error in state: 139.
##
## primary_expression_access -> primary_expression DOT . lname [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression DOT . lname function_call_params [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression DOT . lname COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_access -> primary_expression DOT . lname function_call_params COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## primary_expression DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME EQUAL UNAME PLUS_ASSIGN
##
## Ends in an error in state: 131.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression EQUAL bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression EQUAL bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME EQUAL WHILE
##
## Ends in an error in state: 130.
##
## bin_expression -> bin_expression EQUAL . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME LARGER UNAME PLUS_ASSIGN
##
## Ends in an error in state: 129.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression LARGER bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression LARGER bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME LARGER WHILE
##
## Ends in an error in state: 128.
##
## bin_expression -> bin_expression LARGER . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression LARGER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME LBRACK UNAME SEMI
##
## Ends in an error in state: 137.
##
## plain_primary_expression -> primary_expression LBRACK arithmetic_expression . RBRACK [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## primary_expression LBRACK arithmetic_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 90, spurious reduction of production bin_expression -> unary_expression 
## In state 108, spurious reduction of production arithmetic_expression -> bin_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME LBRACK WHILE
##
## Ends in an error in state: 95.
##
## plain_primary_expression -> primary_expression LBRACK . arithmetic_expression RBRACK [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## primary_expression LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME LEQ UNAME PLUS_ASSIGN
##
## Ends in an error in state: 127.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression LEQ bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression LEQ bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME LEQ WHILE
##
## Ends in an error in state: 126.
##
## bin_expression -> bin_expression LEQ . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression LEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME MINUS UNAME PLUS_ASSIGN
##
## Ends in an error in state: 121.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression MINUS bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression MINUS bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME MINUS WHILE
##
## Ends in an error in state: 120.
##
## bin_expression -> bin_expression MINUS . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME MINUS_ASSIGN WHILE
##
## Ends in an error in state: 151.
##
## plain_assignment -> unary_expression MINUS_ASSIGN . arithmetic_expression [ SEMI RPAREN RBRACK EOF END ELSE ELIF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## unary_expression MINUS_ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME MOD WHILE
##
## Ends in an error in state: 116.
##
## bin_expression -> bin_expression MOD . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression MOD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME MOD_ASSIGN WHILE
##
## Ends in an error in state: 149.
##
## plain_assignment -> unary_expression MOD_ASSIGN . arithmetic_expression [ SEMI RPAREN RBRACK EOF END ELSE ELIF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## unary_expression MOD_ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME MUL_ASSIGN WHILE
##
## Ends in an error in state: 147.
##
## plain_assignment -> unary_expression MUL_ASSIGN . arithmetic_expression [ SEMI RPAREN RBRACK EOF END ELSE ELIF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## unary_expression MUL_ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME NEQ UNAME PLUS_ASSIGN
##
## Ends in an error in state: 125.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression NEQ bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression NEQ bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME NEQ WHILE
##
## Ends in an error in state: 124.
##
## bin_expression -> bin_expression NEQ . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression NEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME PLUS UNAME PLUS_ASSIGN
##
## Ends in an error in state: 115.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression PLUS bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression PLUS bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME PLUS WHILE
##
## Ends in an error in state: 114.
##
## bin_expression -> bin_expression PLUS . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME PLUS_ASSIGN WHILE
##
## Ends in an error in state: 91.
##
## plain_assignment -> unary_expression PLUS_ASSIGN . arithmetic_expression [ SEMI RPAREN RBRACK EOF END ELSE ELIF COMMA COLON ]
##
## The known suffix of the stack is as follows:
## unary_expression PLUS_ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME SEQ UNAME PLUS_ASSIGN
##
## Ends in an error in state: 123.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression SEQ bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression SEQ bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME SEQ WHILE
##
## Ends in an error in state: 122.
##
## bin_expression -> bin_expression SEQ . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression SEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME SMALLER UNAME PLUS_ASSIGN
##
## Ends in an error in state: 113.
##
## bin_expression -> bin_expression . PLUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MINUS bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . STAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . DIVIDE bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . MOD bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LARGER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . LEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SMALLER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression SMALLER bin_expression . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . SEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . AMPERAMPER bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . BARBAR bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . EQUAL bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
## bin_expression -> bin_expression . NEQ bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression SMALLER bin_expression
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 98, spurious reduction of production primary_expression_start -> name 
## In state 92, spurious reduction of production primary_expression_access -> primary_expression_start 
## In state 93, spurious reduction of production plain_primary_expression -> primary_expression_access 
## In state 96, spurious reduction of production mark_position(plain_primary_expression) -> plain_primary_expression 
## In state 101, spurious reduction of production primary_expression -> mark_position(plain_primary_expression) 
## In state 94, spurious reduction of production unary_expression -> primary_expression 
## In state 110, spurious reduction of production bin_expression -> unary_expression 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME SMALLER WHILE
##
## Ends in an error in state: 112.
##
## bin_expression -> bin_expression SMALLER . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression SMALLER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME STAR WHILE
##
## Ends in an error in state: 109.
##
## bin_expression -> bin_expression STAR . bin_expression [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS NEQ MOD MINUS LEQ LARGER EQUAL EOF END ELSE ELIF DIVIDE COMMA COLON BARBAR AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## bin_expression STAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN UNAME WHILE
##
## Ends in an error in state: 98.
##
## primary_expression_start -> name . [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
## primary_expression_start -> name . COLONCOLON gen_ty_consume [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME ASSIGN WHILE
##
## Ends in an error in state: 178.
##
## plain_var_decl -> var_decorator lname ASSIGN . arithmetic_expression [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME COLON UNAME ASSIGN WHILE
##
## Ends in an error in state: 176.
##
## plain_var_decl -> var_decorator lname COLON ty ASSIGN . arithmetic_expression [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname COLON ty ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME COLON UNAME LARGER
##
## Ends in an error in state: 175.
##
## plain_var_decl -> var_decorator lname COLON ty . [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
## plain_var_decl -> var_decorator lname COLON ty . ASSIGN arithmetic_expression [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production ty_apply -> tyname 
## In state 29, spurious reduction of production plain_ty -> ty_apply 
## In state 33, spurious reduction of production mark_position(plain_ty) -> plain_ty 
## In state 35, spurious reduction of production ty -> mark_position(plain_ty) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME COLON UNAME SMALLER UNAME COMMA WHILE
##
## Ends in an error in state: 31.
##
## separated_nonempty_list(COMMA,ty) -> ty COMMA . separated_nonempty_list(COMMA,ty) [ LARGER ]
##
## The known suffix of the stack is as follows:
## ty COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME COLON UNAME SMALLER UNAME SEMI
##
## Ends in an error in state: 30.
##
## separated_nonempty_list(COMMA,ty) -> ty . [ LARGER ]
## separated_nonempty_list(COMMA,ty) -> ty . COMMA separated_nonempty_list(COMMA,ty) [ LARGER ]
##
## The known suffix of the stack is as follows:
## ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production ty_apply -> tyname 
## In state 29, spurious reduction of production plain_ty -> ty_apply 
## In state 33, spurious reduction of production mark_position(plain_ty) -> plain_ty 
## In state 35, spurious reduction of production ty -> mark_position(plain_ty) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME COLON UNAME SMALLER WHILE
##
## Ends in an error in state: 28.
##
## ty_apply -> tyname SMALLER . separated_nonempty_list(COMMA,ty) LARGER [ SEMI RPAREN LARGER EOF END ELSE ELIF COMMA ASSIGN ARROW ]
##
## The known suffix of the stack is as follows:
## tyname SMALLER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME COLON UNAME WHILE
##
## Ends in an error in state: 27.
##
## ty_apply -> tyname . SMALLER separated_nonempty_list(COMMA,ty) LARGER [ SEMI RPAREN LARGER EOF END ELSE ELIF COMMA ASSIGN ARROW ]
## ty_apply -> tyname . [ SEMI RPAREN LARGER EOF END ELSE ELIF COMMA ASSIGN ARROW ]
##
## The known suffix of the stack is as follows:
## tyname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME COLON WHILE
##
## Ends in an error in state: 174.
##
## plain_var_decl -> var_decorator lname COLON . ty [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
## plain_var_decl -> var_decorator lname COLON . ty ASSIGN arithmetic_expression [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET LNAME WHILE
##
## Ends in an error in state: 173.
##
## plain_var_decl -> var_decorator lname . COLON ty [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
## plain_var_decl -> var_decorator lname . COLON ty ASSIGN arithmetic_expression [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
## plain_var_decl -> var_decorator lname . ASSIGN arithmetic_expression [ SEMI RPAREN EOF END ELSE ELIF COMMA ]
##
## The known suffix of the stack is as follows:
## var_decorator lname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET WHILE
##
## Ends in an error in state: 171.
##
## plain_vars_decl -> LET . separated_nonempty_list(COMMA,var_decl) [ SEMI RPAREN EOF END ELSE ELIF ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: PACKAGE COLON LNAME SEMI BREAK
##
## Ends in an error in state: 18.
##
## prog -> option(module_clause) . pkg_body EOF [ # ]
##
## The known suffix of the stack is as follows:
## option(module_clause)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production nonempty_list(single_sep) -> single_sep 
## In state 11, spurious reduction of production sep -> nonempty_list(single_sep) 
## In state 10, spurious reduction of production plain_module_clause -> PACKAGE COLON separated_nonempty_list(DOT,name) sep 
## In state 17, spurious reduction of production mark_position(plain_module_clause) -> plain_module_clause 
## In state 403, spurious reduction of production module_clause -> mark_position(plain_module_clause) 
## In state 402, spurious reduction of production option(module_clause) -> module_clause 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: PACKAGE COLON UNAME DOT WHILE
##
## Ends in an error in state: 13.
##
## separated_nonempty_list(DOT,name) -> name DOT . separated_nonempty_list(DOT,name) [ SEMI ]
##
## The known suffix of the stack is as follows:
## name DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: PACKAGE COLON UNAME WHILE
##
## Ends in an error in state: 12.
##
## separated_nonempty_list(DOT,name) -> name . [ SEMI ]
## separated_nonempty_list(DOT,name) -> name . DOT separated_nonempty_list(DOT,name) [ SEMI ]
##
## The known suffix of the stack is as follows:
## name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: PACKAGE COLON WHILE
##
## Ends in an error in state: 2.
##
## plain_module_clause -> PACKAGE COLON . separated_nonempty_list(DOT,name) sep [ TRAIT LET IMPORT IMPL FN EOF CLASS ]
##
## The known suffix of the stack is as follows:
## PACKAGE COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: PACKAGE WHILE
##
## Ends in an error in state: 1.
##
## plain_module_clause -> PACKAGE . COLON separated_nonempty_list(DOT,name) sep [ TRAIT LET IMPORT IMPL FN EOF CLASS ]
##
## The known suffix of the stack is as follows:
## PACKAGE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME COLON END WHILE
##
## Ends in an error in state: 387.
##
## pkg_body -> pkg_field_decl . [ EOF ]
## pkg_body -> pkg_field_decl . sep pkg_body [ EOF ]
##
## The known suffix of the stack is as follows:
## pkg_field_decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME COLON WHILE
##
## Ends in an error in state: 58.
##
## plain_trait_def -> TRAIT uname option(trait_father) COLON . class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## TRAIT uname option(trait_father) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME LPAREN UNAME RPAREN CLASS
##
## Ends in an error in state: 57.
##
## plain_trait_def -> TRAIT uname option(trait_father) . COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## TRAIT uname option(trait_father)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME LPAREN UNAME SMALLER UNAME COMMA WHILE
##
## Ends in an error in state: 49.
##
## gen_ty_consume_list -> ty COMMA . gen_ty_consume_list [ LARGER ]
##
## The known suffix of the stack is as follows:
## ty COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME LPAREN UNAME SMALLER UNAME LARGER WHILE
##
## Ends in an error in state: 54.
##
## trait_father -> LPAREN uname gen_ty_consume . RPAREN [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN uname gen_ty_consume
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME LPAREN UNAME SMALLER UNAME SEMI
##
## Ends in an error in state: 48.
##
## gen_ty_consume_list -> ty . [ LARGER ]
## gen_ty_consume_list -> ty . COMMA gen_ty_consume_list [ LARGER ]
##
## The known suffix of the stack is as follows:
## ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production ty_apply -> tyname 
## In state 29, spurious reduction of production plain_ty -> ty_apply 
## In state 33, spurious reduction of production mark_position(plain_ty) -> plain_ty 
## In state 35, spurious reduction of production ty -> mark_position(plain_ty) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME LPAREN UNAME SMALLER WHILE
##
## Ends in an error in state: 47.
##
## gen_ty_consume -> SMALLER . gen_ty_consume_list LARGER [ STAR SMALLER SEQ SEMI RPAREN RBRACK PLUS_ASSIGN PLUS NEQ MUL_ASSIGN MOD_ASSIGN MOD MINUS_ASSIGN MINUS LEQ LBRACK LARGER EQUAL EOF END ELSE ELIF DOT DIV_ASSIGN DIVIDE COMMA COLON BARBAR ASSIGN AMPERAMPER ]
##
## The known suffix of the stack is as follows:
## SMALLER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME LPAREN UNAME WHILE
##
## Ends in an error in state: 46.
##
## trait_father -> LPAREN uname . RPAREN [ COLON ]
## trait_father -> LPAREN uname . gen_ty_consume RPAREN [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN uname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME LPAREN WHILE
##
## Ends in an error in state: 45.
##
## trait_father -> LPAREN . uname RPAREN [ COLON ]
## trait_father -> LPAREN . uname gen_ty_consume RPAREN [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME SMALLER GNAME COLON GNAME WHILE
##
## Ends in an error in state: 42.
##
## gen_ty_def_list -> gen_ty . [ LARGER ]
## gen_ty_def_list -> gen_ty . COMMA gen_ty_def_list [ LARGER ]
##
## The known suffix of the stack is as follows:
## gen_ty
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME SMALLER GNAME COLON WHILE
##
## Ends in an error in state: 26.
##
## plain_gen_ty -> genname COLON . ty [ LARGER COMMA ]
##
## The known suffix of the stack is as follows:
## genname COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME SMALLER GNAME COMMA WHILE
##
## Ends in an error in state: 43.
##
## gen_ty_def_list -> gen_ty COMMA . gen_ty_def_list [ LARGER ]
##
## The known suffix of the stack is as follows:
## gen_ty COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME SMALLER GNAME LARGER COLON WHILE
##
## Ends in an error in state: 321.
##
## plain_trait_def -> TRAIT uname gen_ty_def option(trait_father) COLON . class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## TRAIT uname gen_ty_def option(trait_father) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME SMALLER GNAME LARGER LPAREN UNAME RPAREN CLASS
##
## Ends in an error in state: 320.
##
## plain_trait_def -> TRAIT uname gen_ty_def option(trait_father) . COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## TRAIT uname gen_ty_def option(trait_father)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME SMALLER GNAME LARGER WHILE
##
## Ends in an error in state: 319.
##
## plain_trait_def -> TRAIT uname gen_ty_def . option(trait_father) COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## TRAIT uname gen_ty_def
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME SMALLER GNAME WHILE
##
## Ends in an error in state: 25.
##
## plain_gen_ty -> genname . [ LARGER COMMA ]
## plain_gen_ty -> genname . COLON ty [ LARGER COMMA ]
##
## The known suffix of the stack is as follows:
## genname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME SMALLER WHILE
##
## Ends in an error in state: 21.
##
## gen_ty_def -> SMALLER . gen_ty_def_list LARGER [ LPAREN FOR COLON ]
##
## The known suffix of the stack is as follows:
## SMALLER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT UNAME WHILE
##
## Ends in an error in state: 20.
##
## plain_trait_def -> TRAIT uname . gen_ty_def option(trait_father) COLON class_body END [ SEMI EOF ]
## plain_trait_def -> TRAIT uname . option(trait_father) COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## TRAIT uname
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: TRAIT WHILE
##
## Ends in an error in state: 19.
##
## plain_trait_def -> TRAIT . uname gen_ty_def option(trait_father) COLON class_body END [ SEMI EOF ]
## plain_trait_def -> TRAIT . uname option(trait_father) COLON class_body END [ SEMI EOF ]
##
## The known suffix of the stack is as follows:
## TRAIT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE
##
## Ends in an error in state: 0.
##
## prog' -> . prog [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

